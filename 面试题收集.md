##### 1、DDL、DML等等区别了解一下

##### 2、redis一致性问题

##### 3、B+树相较于其他的优点

相较于B树，B+树的查询I/O次数少、查询效率稳定、便于区间查询和扫库

##### 4、动态多态和静态多态

> **静态多态性指的是程序在编译时，系统就能决定调用哪个函数，如重载。** 
> **动态多态性指在运行中才能动态确定操作指针所指的对象，主要通过虚函数和重写来实现。** 
> java 的多态机制遵循一个原则：当父类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法 
> 概念理解起来有点抽象。还是看个例子吧。 
> `静态多态性：` 
> `add(int a);` 
> `add(int a,int b);` 
> `add(double a);` 
> `add(double a,double b);` 
>
> `动态多态性` 
> `public class A{ }` 
>
> `public class AB extends A{ }` 
>
> `public class AC extends A{ }` 
>
> `public class test{` 
>   `go(A a);`

##### 5、哈希表为什么用红黑树不用平衡二叉树

> 在Jdk1.8版本后，Java对HashMap做了改进，在链表长度大于8的时候，将后面的数据由链表改为了存在红黑树中，以加快检索速度。
>
> 有疑问为什么是使用红黑树而不是AVL树，AVL树是完全平衡二叉树阿？
>
> 最主要的一点是：
>
> 在CurrentHashMap中是加锁了的，实际上是读写锁，如果写冲突就会等待，
> 如果插入时间过长必然等待时间更长，而红黑树相对AVL树他的插入更快！
>
> 问题：为什么不使用AVL树而使用红黑树？
> 红黑树和AVL树都是最常用的平衡二叉搜索树，它们的查找、删除、修改都是O(lgn) time
>
> AVL树和红黑树有几点比较和区别：
> （1）AVL树是更加严格的平衡，因此可以提供更快的查找速度，一般读取查找密集型任务，适用AVL树。
> （2）红黑树更适合于插入修改密集型任务。
> （3）**通常，AVL树的旋转比红黑树的旋转更加难以平衡和调试。**
>
> 总结：
> （1）AVL以及红黑树是高度平衡的树数据结构。它们非常相似，真正的区别在于在任何添加/删除操作时完成的旋转操作次数。
> （2）两种实现都缩放为a O(lg N)，其中N是叶子的数量，但实际上AVL树在查找密集型任务上更快：利用更好的平衡，树遍历平均更短。另一方面，插入和删除方面，AVL树速度较慢：需要更高的旋转次数才能在修改时正确地重新平衡数据结构。
> （3）在AVL树中，从根到任何叶子的最短路径和最长路径之间的差异最多为1。在红黑树中，差异可以是2倍。
> （4）两个都给O（log n）查找，但平衡AVL树可能需要O（log n）旋转，而红黑树将需要最多两次旋转使其达到平衡（尽管可能需要检查O（log n）节点以确定旋转的位置）。旋转本身是O（1）操作，因为你只是移动指针。

##### 6、websocket

##### 7、什么样的索引数据结构是好的？

> 磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，操作系统一次会读写多个扇区，所以操作系统的最小读写单位是块（Block）。Linux 中的块大小为 4KB，也就是一次磁盘 I/O 操作会直接读写 8 个扇区。
>
> 由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。
>
> 所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘 I/O 操作越少，所消耗的时间也就越小。
>
> 另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。
>
> 所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：
>
> ①能在尽可能少的磁盘的 I/O 操作中完成查询工作；
> ②要能高效地查询某一个记录，也要能高效地执行范围查找；

##### 8、为什么新生代采用标记复制算法？老年用标记复制呢？

> 不同收集器可能采用的算法不一样，我们这里是对serial 以及ParNew 垃圾收集器进行说明。
>
> **为什么新生代采用标记复制算法？**
> 首先明确一点，新创建的对象一般都会先分配在新生代，进行垃圾回收时，会有很多垃圾需要清除。
> 采用标记复制，我们只需要将不是垃圾的对象标记出来，给他复制到另一块去，然后把现在这一块直接干掉。
> 比如说我是一个捡垃圾的老太太，我现在找到了一个垃圾箱，我就在里面翻一翻，把有用的瓶子拿走了，其他都不要。这就是标记复制的思想。
>
> **为什么老年代不采用标记复制，而是标记整理嘞？**
> 首先我们再来明确一点，在老年代的对象要么存活时间比较久，也就是说有用的对象比较多，要么对象比较大，新生代直接放不下。
> 这个时候如果我们采用标记复制算法，需要复制的代价就比较高（因为需要留下来的对象比较多，而且可能会很大），不划算，当然其实标记整理算法需要的代价也不低，那为什么还要采用呢？因为复制算法有一个缺点，就是每次只能用一半的空间，会比较浪费，既然复制和整理代价都高，复制算法还只能用一半，那肯定就选择标记整理了啦。
> 不过现在新一些的垃圾收集器已经不采用了，像CMS和G1他们就已经不一样了。

##### 9、什么是GraalVM？

> 上面提到的所有技术放到一张图里面，这个整体就叫做GraalVM，其实并不真正存在GraalVM这个语言虚拟机，GraalVM是指**以Java虚拟机为基础**，**以Graal即时编译器为核心**，以能运行多种语言为目标，包含一系列框架和技术的大杂烩：
>
> ![img](https://picx.zhimg.com/v2-7205d1f7d9ff516da1ff8628dd655639_r.jpg?source=2c26e567)

##### 10、mysql数据库什么时候用全局锁、表级锁、行级锁？

##### 11、排序算法稳定性？

> 选择排序：不稳定
>
> 冒泡排序：稳定
>
> 插入排序：稳定
>
> 快速排序：不稳定
>
> 归并排序：稳定

##### 12、实现限流的几种策略

##### 13、spring事务传播
